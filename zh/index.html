<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
	<meta name="generator" content="Hugo 0.129.0">
    
      <meta name="theme" content='FixIt v0.3.9'>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>*&lt;^_^&gt;*</title><meta name="author" content="caijin">
<meta name="author-link" content="https://caijin.dev">
<meta name="description" content="" />
  <meta itemprop="name" content="*&lt;^_^&gt;*">
  <meta itemprop="datePublished" content="2020-05-02T20:20:42+08:00">
  <meta itemprop="dateModified" content="2020-05-02T20:20:42+08:00"><meta property="og:url" content="https://caijin.dev/zh/">
  <meta property="og:site_name" content="*&lt;^_^&gt;*">
  <meta property="og:title" content="*&lt;^_^&gt;*">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="*&lt;^_^&gt;*">
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="https://caijin.dev/zh/" /><link rel="alternate" href="/zh/index.xml" type="application/rss+xml" title="*&lt;^_^&gt;*">
  <link rel="feed" href="/zh/index.xml" type="application/rss+xml" title="*&lt;^_^&gt;*"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "WebSite",
    "url": "https:\/\/caijin.dev\/zh\/","inLanguage": "zh-CN","author": {
        "@type": "Person",
        "name": "caijin"
      },"license": "xxxx","name": "*\u003c^_^\u003e*"
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/zh/" title="*&lt;^_^&gt;*"><span class="header-title-text">*&lt;^_^&gt;*</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item active">
              <a
                class="menu-link"
                href="/zh/"
                
                
              >文档</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/zh/categories/"
                
                
              >分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/zh/tags/"
                
                
              >标签</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="https://github.com/CaiJinKen"
                
                rel="noopener noreferrer" target="_blank"
              ><i class="fa fa-heart" style="color:red"></i> github</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li><li class="menu-item language-switch">
            <span role="button" aria-label="" title=""><i class="fa-solid fa-language fa-fw" aria-hidden="true"></i></span>
            <ul class="sub-menu"><li class="menu-item">
                      <span class="menu-link text-secondary" title="简体中文">简体中文</span>
                    </li><li class="menu-item">
                      <a href="/en/" class="menu-link" title="English">English</a>
                    </li></ul>
          </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/zh/" title="*&lt;^_^&gt;*"><span class="header-title-text">*&lt;^_^&gt;*</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li
              class="menu-item active"
            ><a
                  class="menu-link"
                  href="/zh/"
                  
                  
                >文档</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/zh/categories/"
                  
                  
                >分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/zh/tags/"
                  
                  
                >标签</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="https://github.com/CaiJinKen"
                  
                  rel="noopener noreferrer" target="_blank"
                ><i class="fa fa-heart" style="color:red"></i> github</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title=""><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span><span class="menu-system-item language-switch">
              <span role="button" aria-label="" title="">简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden="true"></i></span>
              <select class="language-select" onchange="location = this.value;"><option value="/zh/" selected disabled>简体中文</option><option value="/en/">English</option></select>
            </span></li>
      </ul>
    </nav>
  </div>
</header><main class="container"><div class="page home posts"><article class="single summary" itemscope itemtype="http://schema.org/Article"><h2 class="single-title" itemprop="name headline"><a href="/zh/docker-&#43;-gitlab-&#43;-jenkins-%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/">Docker &#43; Gitlab &#43; Jenkins 搭建持续集成环境</a>
  </h2><div class="post-meta"><span class="post-author"><a href="https://caijin.dev"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="https://avatars.githubusercontent.com/u/36183188?s=400&amp;u=69ec665b3e4ffcc40a98072d56fbaa5b044c5968&amp;v=4" alt="caijin" data-title="caijin" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;caijin</a></span>&nbsp;<span class="post-publish" title='2020-05-02 20:20:42'></span><span class="post-included-in">&nbsp;</span></div><div class="content">Docker + Gitlab + Jenkins 搭建持续集成环境 安装docker sudo apt update sudo apt install apt-transport-https \ ca-certificates \ curl \ gnupg-agent \ software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \ &#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable&#34; sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io安装Gitlab sudo docker pull gitlab/gitlab-ce:nightly由于众所周知的原因，国内拉取某些镜像慢的一批，所以我们需要把docker镜像源换一下，
sudo vim /etc/docker/daemon.json我这里替换为网易和百度的源，当然也可以换成任意你想要的一个或多个
{ &#34;registry-mirrors&#34;: [ &#34;https://hub-mirror.c.163.com&#34;, &#34;https://mirror.baidubce.com&#34; ] }之后，重启docker
sudo systemctl daemon-reload sudo systemctl restart docker镜像拉取好了以后，启动容器</div><div class="post-footer">
    <a href="/zh/docker-&#43;-gitlab-&#43;-jenkins-%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/"></a><div class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/zh/tags/others/' class="post-tag">Others</a></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h2 class="single-title" itemprop="name headline"><a href="/zh/redis/redis-%E5%85%B6%E4%BB%96/">Redis必知必会</a>
  </h2><div class="post-meta"><span class="post-author"><a href="https://caijin.dev"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="https://avatars.githubusercontent.com/u/36183188?s=400&amp;u=69ec665b3e4ffcc40a98072d56fbaa5b044c5968&amp;v=4" alt="caijin" data-title="caijin" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;caijin</a></span>&nbsp;<span class="post-publish" title='2020-05-02 20:20:42'></span><span class="post-included-in">&nbsp;</span></div><div class="content">Redis 其他 redis 数据淘汰机制 当机器内存不够的时候（达到物理机器或者配置的内存上限时），redis会依据数据淘汰机制淘汰一部分数据，有以下6种方式：
volatile-lru： 在设置了过期时间的key中，使用LRU（最近最少使用）算法，将最近最少使用的key淘汰 volatile-ttl： 在设置了过期时间的key中，根据TTL（time to live）时间，将快要过期的数据淘汰 volatile-random： 在设置了过期时间的key中，随机淘汰数据 allkeys-lru： 在所有key中，淘汰最近最少使用的数据 allkeys-random： 在所有key中，随机淘汰数据 noeviction： 禁止淘汰数据 redis缓存穿透、击穿、雪崩 缓存穿透：请求数据在redis中查询，查询不到，最后请求落到了数据库 缓存击穿：热门数据突然失效，大量请求到了数据库 缓存雪崩：大量数据同时失效 Note: 解决方案：
穿透：对于非法参数（eg：id&lt;=0）增加参数校验，过滤掉不存在数据的请求；对于合法参数(eg: id=xxxx)，但是数据不存在：将数据设置为null 击穿：设置热点数据永不过期 雪崩：避免大量数据同一时间过期：分散过期时间；分散数据到不同缓存数据库 master-slave 作用：主从备份，防止节点宕机；读写分离，达到负载均衡目的，提高系统吞吐量 全量同步，发生在slave初始化阶段： slave连接master，发送SYNC命令 master收到命令后，开始执行BGSAVE命令生成rdb文件，并使用缓冲区记录此后所执行的_写命令_ master执行完BGSAVE命令后，向所有slave发送rdb文件 slave收到rdb文件后，丢弃所有旧数据，载入收到的数据 master发送完文件后，就开始放送缓冲区中的写命令 slave完成数据载入后，开始接收命令请求，并执行来自master同步的写命令 增量同步：slave初始化后正常工作，接收master发送的写命令。master每执行一个写命令就会向slave发送相同的写命令，slave接收并执行收到的写命令 同步策略：master、slave刚刚连接的时候，进行全量同步；全量同步结束后开始增量同步。如果有需要的话，slave在任何时候都可以发起全量同步。redis策略为，首先先进行增量同步，如不成功，进行全量同步 </div><div class="post-footer">
    <a href="/zh/redis/redis-%E5%85%B6%E4%BB%96/"></a><div class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/zh/tags/redis/' class="post-tag">Redis</a></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h2 class="single-title" itemprop="name headline"><a href="/zh/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/">Redis持久化</a>
  </h2><div class="post-meta"><span class="post-author"><a href="https://caijin.dev"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="https://avatars.githubusercontent.com/u/36183188?s=400&amp;u=69ec665b3e4ffcc40a98072d56fbaa5b044c5968&amp;v=4" alt="caijin" data-title="caijin" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;caijin</a></span>&nbsp;<span class="post-publish" title='2020-05-02 20:20:42'></span><span class="post-included-in">&nbsp;</span></div><div class="content">redis持久化 两种方式：RDB、AOF
RDB，redis-database，使用压缩的二进制文件保存的是redis内存中完整的数据，相当于数据的快照，默认的持久化方式，可以手动执行以下命令执行，可以在配置文件中自动执行
SAVE命令：会阻塞服务器进程，此时所有命令都会一直阻塞直到save命令执行完毕 BGSAVE命令：会重新起一个进程处理，不会阻塞任何命令 恢复过程：
如果没开启AOF持久化，服务器才会使用RDB文件还原数据 如果开启了AOF持久化，服务器会优先使用AOF文件还原数据 AOF，append-only-file，默认关闭，服务器在执行完写命令后，会以协议格式将命令追加到AOF缓冲区，然后服务器根据appendfsync选项决定何时将AOF缓冲区内容写入到AOF文件。
appendfsync：
always，每个写命令都会同步到AOF文件，是最安全的方式，即使故障停机，丢失数据最多就一个写命令的数据 everysec，每秒钟都会同步数据到AOF文件，故障停机最多就丢失一秒钟的写入命令的数据，是AOF方式的默认值 no，从不同步数据，出现故障后，会丢失上次同步之后的所有写入数据 恢复过程：
创建一个伪客户端 从AOF文件分析并读取一条写命令 伪客户端执行命令 重复上两个步骤，直到AOF文件所有写命令执行完毕 随着运行时间的增加，AOF文件会越来越大，占用的磁盘空间会增加，而且数据恢复的过程所耗费的时间也会增加，为了解决这一问题，redis提供了AOF重写功能：redis会创建一个新的AOF文件替代现有AOF文件，新旧两个文件保存的数据相同，只不过新AOF文件保存的是精简后的命令，不会浪费存储空间
AOF重写过程：
服务器创建子进程，子进程开始AOF文件重写 服务器执行所有命令外还要将写命令写入AOF缓冲区和AOF重写缓冲区 子进程完成AOF重写后向父进程发送信号，父进程收到信号后： 将AOF重写缓冲区内容写入到新AOF文件中，保证新AOF文件保存的数据和服务器当前的数据一致 对新AOF文件重命名，覆盖现有AOF文件，完成新旧AOF文件替换 两种持久化方式的区别 实现方式
RDB持久化记录的是结果，AOF持久化记录的是过程
文件体积
记录结果的方式肯定比记录过程的方式占用的存储空间小，即：RDB文件占用的存储空间小
安全性
AOF的安全性要比RDB的高。RDB持久化会丢失从上次保存以后的数据，而AOF持久化最多丢失1s的数据
优先级
AOF的优先级比RDB的高</div><div class="post-footer">
    <a href="/zh/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/"></a><div class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/zh/tags/redis/' class="post-tag">Redis</a></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h2 class="single-title" itemprop="name headline"><a href="/zh/golang/unsafe.pointer/">Unsafe.Pointer</a>
  </h2><div class="post-meta"><span class="post-author"><a href="https://caijin.dev"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="https://avatars.githubusercontent.com/u/36183188?s=400&amp;u=69ec665b3e4ffcc40a98072d56fbaa5b044c5968&amp;v=4" alt="caijin" data-title="caijin" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;caijin</a></span>&nbsp;<span class="post-publish" title='2020-05-02 20:20:42'></span><span class="post-included-in">&nbsp;</span></div><div class="content">unsafe.Pointer相当于指向任意类型的指针(*指针)，但它有四种特殊的操作不同于一般的指针：
任意类型的指针(*)可以转换为Pointer Pointer指针也可以转换为任意类型的指针 uintptr可以转换成Pointer Pointer可以也可以转换为uintptr 即:
Pointer &lt;&mdash;&gt;(*)
uintptr&lt;&mdash;-&gt; Pointer
Pointer允许程序忽略类型检测从而读写任意的内存，所以在使用unsafe包的时候要格外小心。
比如将float64转化为int64，正常情况下是需要遵守go的类型检测，进行类型强转之后才能正常运行：
var ( sourceValue float64 targetValue int46 ) sourceValue = 300.00 targetValue = int64(sourceValue) // targetValue = sourceValue //err: type not match 使用示例：
将*T1转换为*T2
func Float64bits(f float64) uint64{ return (*uint64)(unsafe.Pointer(&amp;f)) } //unsafe.Pointer(&amp;f)即第一条规则：将任意类型指针转换为Pointer //(*uint64)(unsafe.Pointer)即第二条规则：将Pointer转换为任意类型 将Pointer转换为uintptr(取地址值)
func Pointer2uintptr(p unsafe.Pointer) uintprt{ return (uintptr)(p) } //(uintprt)(unsafe.Pointer)即第三条规则：将Pointer转换为uintptr Note:一般情况下不要这么用，因为uintptr本质上是整数类型，当Pointer中的指针值变了以后，uintptr的值并不随着原始指针的值变化，这里仅仅只是出于演示的目的这么写，所以别用任何变量保存Pointer转换为uintptr之后的值
将指针和偏移做运算以后返回
p = unsafe.Pointer(uintptr(p)+offset) //offset 是一个整型的值，可以是计算后的，比如 //对于结构体： f = unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s))+unsafe.Offsetof(s.f)) //上面等同于 f = unsafe.Pointer(&amp;s.f) //对于slice e := unsafe.</div><div class="post-footer">
    <a href="/zh/golang/unsafe.pointer/"></a><div class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/zh/tags/golang/' class="post-tag">Golang</a></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h2 class="single-title" itemprop="name headline"><a href="/zh/golang/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">Golang内存对齐</a>
  </h2><div class="post-meta"><span class="post-author"><a href="https://caijin.dev"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="https://avatars.githubusercontent.com/u/36183188?s=400&amp;u=69ec665b3e4ffcc40a98072d56fbaa5b044c5968&amp;v=4" alt="caijin" data-title="caijin" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;caijin</a></span>&nbsp;<span class="post-publish" title='2020-05-02 20:18:42'></span><span class="post-included-in">&nbsp;</span></div><div class="content">golang内存对齐 一个golang的结构体，在内存中是如何存放的呢？即，结构体的内存结构是什么样的呢？有没有优化的空间呢？今天来一探究竟
note:我所用的是64bite的机器，在32位的机器有些类型的大小是不一样的，比如int
基本数据类型的大小
var ( boolField bool byteField byte int8Field int8 int16Field int16 int32Field int32 intField int int64Field int64 float32Field float32 float64Field float64 stringField string mapField map[string]interface{} sliceField []interface{} ) fmt.Println(unsafe.Sizeof(boolField)) //1 fmt.Println(unsafe.Sizeof(byteField)) //1 fmt.Println(unsafe.Sizeof(int8Field)) //1 fmt.Println(unsafe.Sizeof(int16Field)) //2 fmt.Println(unsafe.Sizeof(int32Field)) //4 fmt.Println(unsafe.Sizeof(intField)) //8 fmt.Println(unsafe.Sizeof(int64Field)) //8 fmt.Println(unsafe.Sizeof(float32Field)) //4 fmt.Println(unsafe.Sizeof(float64Field)) //8 fmt.Println(unsafe.Sizeof(stringField)) //16 fmt.Println(unsafe.Sizeof(mapField)) //8 fmt.Println(unsafe.Sizeof(sliceField)) //24 note: unsafe.Sizeof()返回的是字节数，如果有这么一个结构体，它所占用的内存是28B么？
type testStruct struct { boolField bool stringField string byteField byte int64Field int64 int16Field int16 }运行一下看看：</div><div class="post-footer">
    <a href="/zh/golang/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"></a><div class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/zh/tags/golang/' class="post-tag">Golang</a></div></div>
</article>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h2 class="single-title" itemprop="name headline"><a href="/zh/kafka/kafka/">Kafka简介</a>
  </h2><div class="post-meta"><span class="post-author"><a href="https://caijin.dev"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="https://avatars.githubusercontent.com/u/36183188?s=400&amp;u=69ec665b3e4ffcc40a98072d56fbaa5b044c5968&amp;v=4" alt="caijin" data-title="caijin" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;caijin</a></span>&nbsp;<span class="post-publish" title='2020-05-02 20:18:42'></span><span class="post-included-in">&nbsp;</span></div><div class="content">Kafka 一、基本概念 kafka cluster：kafka集群，一个集群由多个实例（broker）组成，通过zookeeper进行元数据（brokerID、broker 地址等信息，partition的leader、follower信息等）共享与同步 broker：kafka集群中的一个kafka服务实例，集群内每个broker都有一个不重复的编号，如broker-0、broker-1 producer：消息生产者 topic：消息主题，可以理解为消息分类，为逻辑概念。Kafka的消息就保存在topic，每个broker上都可以创建多个topic。 partition：topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高Kafka的吞吐量。同一个topic在不同分区的数据是不重复的，partition的表现形式就是一个个文件夹，为物理概念。 replication：分区的副本，副本的作用就是提高Kafka的可靠性和可用性。同一个partition有多个replication的情况下，会通过zookeeper选出一个leader，其余的为follower，producer/consumer 读写partition的时候，就是通过leader进行的。当leader不可用时，会选择一个follower成为leader。在Kafka中，默认的最大副本数量是10个，而且副本的数量不能超过broker数量 consumer：消息消费者 consumer group：消息消费者组。为了提高Kafka的吞吐量。可以将多个consumer组成一个group，同一个partition数据只能被group中的一个consumer消费。同一个group里的consumer可以消费同一个topic的不同分区的数量。这样也可以保证，同一消息，不会被重复消费 二、Kafka核心规则 工作流程
producer先从集群中获取分区的leader producer将消息发送给leader leader将消息写入本地文件 follower从leader pull 消息 follower将消息写入本地文件后，向leader发送ACK leader收到所有副本的ACK后，向producer发送ACK 每条消息是追加到分区中，顺序写入磁盘，所以保证同一分区的数据是有序的 producer采用push模式将消息发布到broker follower是主动去leader pull消息进行同步的 producer如何确定数据该写到那个partition partition在写入的时候，可以指定需要写入的partition；如果指定，则写入对应的partition 如果没有指定partition，但是设置了key，则会根据key的值hash到一个partition 如果既没有partition，也没有key，则会轮询选出一个partition 如何保证消息不丢失：producer写入消息、follower同步leader消息的时候，都会返回ACK，通过ACK应答机制，可以确保消息不丢。在生产者向kafka写数据的时候，可以设定参数acks来确定kafka是否确认收到数据，这个值可以设置为0、1、all
0代表producer消息发往cluster不需要等到cluster返回ACK消息，所以设置这个值不能确保消息发送成功，安全性最低，但是效率最高 1代表producer消息发往cluster时，只要leader应答就可以发送下一条，所以这个设置只能确保发送给leader成功 all代表producer消息发往cluster时，需要所有的follower都完成从leader同步，才会发送下一条，确保leader发送成功并且所有follower都完成备份。安全性最高，但是效率最低 数据保存
partition结构：每个partition文件夹由多个segment文件组成，每组segment文件包含.index、.log文、.timeindex三个文件，其中.index、.log文件为索引文件，log文件就是存储message的地方。Kafka就是利用segment+index的方式解决查询效率低问题 message结构：message主要包含消息体、消息大小、offset、压缩类型等信息 存储策略：无论message是否被消费，Kafka都会保存所有消息，对于旧数据删除策略有两种：基于时间，默认7天；基于大小，默认1GB。 consumer group中consumer和partition的关系：
一个consumer可以消费多个partition中的数据 一个partition只能被一个consumer消费 三、Kafka吞吐量大的原因 四、QA leader的选举
kafka不是多数投票选举leader。kafka动态维护一组同步leader数据的副本（ISR in-sync-replication），只有这个组的成员才有资格当选leader，kafka副本写入不被认为是已提交，直到所有的同步副本已经接收才认为。这组ISR保存在zookeeper，正因为如此，在ISR中的任何副本都有资格当选leader，这是kafka的使用模型，有多个分区和确保leader平衡是很重要的一个重要因素。有了这个模型，ISR和f+1副本，kafka的主题可以容忍f失败而不会丢失已提交的消息。
成为ISR列表中的一员，需要满足两个条件：
副本节点必须能与zookeeper保持会话（心跳机制💗） 副本能够复制leader上的所有写操作，并且不能落后太多（卡住或滞后的副本由replica.lag.time.max.ms配置） 一旦follower从leader同步数据的延迟超过阀值，leader就会把它从ISR中剔除，放入OSR，新加入的follower也会加入OSR
AR(assigned replicas) = ISR+OSR (out of-sync-replicas)
如何保证已提交的信息不丢失
replication+leader选举机制</div><div class="post-footer">
    <a href="/zh/kafka/kafka/"></a><div class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/zh/tags/kafka/' class="post-tag">Kafka</a></div></div>
</article>
<ul class="pagination"><li class="page-item active">
          <span class="page-link">
            <a href="/zh/">1</a>
          </span>
        </li><li class="page-item">
          <span class="page-link">
            <a href="/zh/page/2/">2</a>
          </span>
        </li><li class="page-item">
          <span class="page-link">
            <a href="/zh/page/3/">3</a>
          </span>
        </li></ul></div></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered order-2">
        </div><div class="footer-line copyright order-1" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2024</span><span class="author" itemprop="copyrightHolder">
              <a href="https://caijin.dev"target="_blank" rel="external nofollow noopener noreferrer">caijin</a></span><span class="license footer-divider">MIT</span></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label=""><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><noscript>
    <div class="noscript-warning"></div>
  </noscript>
</div><link rel="preload" href="/lib/katex/katex.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/katex/katex.min.css"></noscript><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script src="/js/flyfish.js" defer></script><script>window.config={"code":{"copyTitle":"","editLockTitle":"","editUnLockTitle":"","editable":true,"maxShownLines":10},"cookieconsent":{"content":{"dismiss":"","link":"","message":""},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"version":"v0.3.9"};</script><script src="/js/theme.min.js" defer></script></body>
</html>

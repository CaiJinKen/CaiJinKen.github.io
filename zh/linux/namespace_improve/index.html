<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>Namespace_Improve - *&lt;^_^&gt;*</title><meta name="author" content="caijin">
<meta name="author-link" content="https://caijin.dev">
<meta name="description" content="在上一篇namespace的文章中，我们了解并通过程序写了一个简单版的容器，体验了Linux namespace的功能，但是还有两个美中不足的地方，一个是需要使用root权限才能够运行我们的程序，另外一个我们在容器中使用ps看到pid为1的进程是/proc/self/exe child sh，而不是sh。所以这篇文章就讲讲如何解决这两个问题。
root权限 在Linux namespace中，只有user namespace 是可以被普通用户创建的，其他的namespace 都需要有root权限才可以。但这样就会有问题：
1、并不是每个用户都有sudo权限；
2、进程的安全性。
其实第一点还好解决，关键是第二点，运行的进程是以root权限运行的，这就有可能导致安全问题，比如，容器内的进程受到攻击，控制权到了攻击者的手中，此时的进程是用root权限运行的，所以攻击者可以用该进程执行任意权限的操作。
也有人可能会想，我们不是已经把所有的namespace都clone出来了么，rootfs也改变了，即使被攻击了，影响的范围也就是container中。说的是没错，不过，如果我们把主机的目录当作卷挂载到了container中，那么攻击者所能影响的范围就扩大到了主机中。所以，我们就把这个影响减少到最少&mdash;当前用户的权限。看看代码：
uid := os.Getuid() gid := os.Getgid() cmd.SysProcAttr = &amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUSER | syscall.CLONE_NEWUTS | syscall.CLONE_NEWNS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWNET | syscall.CLONE_NEWPID, UidMappings: []syscall.SysProcIDMap{{0, uid, 1}}, GidMappings: []syscall.SysProcIDMap{{0, gid, 1}}, Credential: &amp;syscall.Credential{ Uid: 0, Gid: 0, }, }第一行和第二行得到当前登陆用户的uid/gid (user id/ group id)；
第六行，我们做了一个uid的映射，syscall.SysProcIDMap第一个参数是容器内的用户的id，0是root，第二个参数是需要映射的用户的权限，第三个参数是映射范围，一般用1就可以，表示一一对应；第七行也是一样，只不过是gid的映射；
第8行，设置容器内用户的uid和gid，都为0，说明是用户是root，用户所在的组是root组
重新编译运行：
jin@k53:~/go-test$ go build namespace.go jin@k53:~/go-test$ ./namespace run sh p pid: 4342 c p pid: 0 c pid: 1 / # / # 可以看到现在不用root权限就可以运行了。docker 也不需要root权限就能运行呢，向docker又前进了一小步，而且，容器内是root，容器外，sh其实是以普通用户执行的，安全性又得到了保证。其实这种安全性是很粗糙的，关于容器的安全性，是一个比较有意思的话题，后面也许会单独谈谈。" /><meta name="keywords" content='linux, docker' />
  <meta itemprop="name" content="Namespace_Improve">
  <meta itemprop="description" content="在上一篇namespace的文章中，我们了解并通过程序写了一个简单版的容器，体验了Linux namespace的功能，但是还有两个美中不足的地方，一个是需要使用root权限才能够运行我们的程序，另外一个我们在容器中使用ps看到pid为1的进程是/proc/self/exe child sh，而不是sh。所以这篇文章就讲讲如何解决这两个问题。
root权限 在Linux namespace中，只有user namespace 是可以被普通用户创建的，其他的namespace 都需要有root权限才可以。但这样就会有问题：
1、并不是每个用户都有sudo权限；
2、进程的安全性。
其实第一点还好解决，关键是第二点，运行的进程是以root权限运行的，这就有可能导致安全问题，比如，容器内的进程受到攻击，控制权到了攻击者的手中，此时的进程是用root权限运行的，所以攻击者可以用该进程执行任意权限的操作。
也有人可能会想，我们不是已经把所有的namespace都clone出来了么，rootfs也改变了，即使被攻击了，影响的范围也就是container中。说的是没错，不过，如果我们把主机的目录当作卷挂载到了container中，那么攻击者所能影响的范围就扩大到了主机中。所以，我们就把这个影响减少到最少—当前用户的权限。看看代码：
uid := os.Getuid() gid := os.Getgid() cmd.SysProcAttr = &amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUSER | syscall.CLONE_NEWUTS | syscall.CLONE_NEWNS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWNET | syscall.CLONE_NEWPID, UidMappings: []syscall.SysProcIDMap{{0, uid, 1}}, GidMappings: []syscall.SysProcIDMap{{0, gid, 1}}, Credential: &amp;syscall.Credential{ Uid: 0, Gid: 0, }, }第一行和第二行得到当前登陆用户的uid/gid (user id/ group id)；
第六行，我们做了一个uid的映射，syscall.SysProcIDMap第一个参数是容器内的用户的id，0是root，第二个参数是需要映射的用户的权限，第三个参数是映射范围，一般用1就可以，表示一一对应；第七行也是一样，只不过是gid的映射；
第8行，设置容器内用户的uid和gid，都为0，说明是用户是root，用户所在的组是root组
重新编译运行：
jin@k53:~/go-test$ go build namespace.go jin@k53:~/go-test$ ./namespace run sh p pid: 4342 c p pid: 0 c pid: 1 / # / # 可以看到现在不用root权限就可以运行了。docker 也不需要root权限就能运行呢，向docker又前进了一小步，而且，容器内是root，容器外，sh其实是以普通用户执行的，安全性又得到了保证。其实这种安全性是很粗糙的，关于容器的安全性，是一个比较有意思的话题，后面也许会单独谈谈。">
  <meta itemprop="datePublished" content="2019-08-16T21:03:23+08:00">
  <meta itemprop="dateModified" content="2019-08-16T21:03:23+08:00">
  <meta itemprop="wordCount" content="273">
  <meta itemprop="keywords" content="Linux,Docker"><meta property="og:url" content="https://caijin.dev/zh/linux/namespace_improve/">
  <meta property="og:site_name" content="*&lt;^_^&gt;*">
  <meta property="og:title" content="Namespace_Improve">
  <meta property="og:description" content="在上一篇namespace的文章中，我们了解并通过程序写了一个简单版的容器，体验了Linux namespace的功能，但是还有两个美中不足的地方，一个是需要使用root权限才能够运行我们的程序，另外一个我们在容器中使用ps看到pid为1的进程是/proc/self/exe child sh，而不是sh。所以这篇文章就讲讲如何解决这两个问题。
root权限 在Linux namespace中，只有user namespace 是可以被普通用户创建的，其他的namespace 都需要有root权限才可以。但这样就会有问题：
1、并不是每个用户都有sudo权限；
2、进程的安全性。
其实第一点还好解决，关键是第二点，运行的进程是以root权限运行的，这就有可能导致安全问题，比如，容器内的进程受到攻击，控制权到了攻击者的手中，此时的进程是用root权限运行的，所以攻击者可以用该进程执行任意权限的操作。
也有人可能会想，我们不是已经把所有的namespace都clone出来了么，rootfs也改变了，即使被攻击了，影响的范围也就是container中。说的是没错，不过，如果我们把主机的目录当作卷挂载到了container中，那么攻击者所能影响的范围就扩大到了主机中。所以，我们就把这个影响减少到最少—当前用户的权限。看看代码：
uid := os.Getuid() gid := os.Getgid() cmd.SysProcAttr = &amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUSER | syscall.CLONE_NEWUTS | syscall.CLONE_NEWNS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWNET | syscall.CLONE_NEWPID, UidMappings: []syscall.SysProcIDMap{{0, uid, 1}}, GidMappings: []syscall.SysProcIDMap{{0, gid, 1}}, Credential: &amp;syscall.Credential{ Uid: 0, Gid: 0, }, }第一行和第二行得到当前登陆用户的uid/gid (user id/ group id)；
第六行，我们做了一个uid的映射，syscall.SysProcIDMap第一个参数是容器内的用户的id，0是root，第二个参数是需要映射的用户的权限，第三个参数是映射范围，一般用1就可以，表示一一对应；第七行也是一样，只不过是gid的映射；
第8行，设置容器内用户的uid和gid，都为0，说明是用户是root，用户所在的组是root组
重新编译运行：
jin@k53:~/go-test$ go build namespace.go jin@k53:~/go-test$ ./namespace run sh p pid: 4342 c p pid: 0 c pid: 1 / # / # 可以看到现在不用root权限就可以运行了。docker 也不需要root权限就能运行呢，向docker又前进了一小步，而且，容器内是root，容器外，sh其实是以普通用户执行的，安全性又得到了保证。其实这种安全性是很粗糙的，关于容器的安全性，是一个比较有意思的话题，后面也许会单独谈谈。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="linux">
    <meta property="article:published_time" content="2019-08-16T21:03:23+08:00">
    <meta property="article:modified_time" content="2019-08-16T21:03:23+08:00">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Docker">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Namespace_Improve">
  <meta name="twitter:description" content="在上一篇namespace的文章中，我们了解并通过程序写了一个简单版的容器，体验了Linux namespace的功能，但是还有两个美中不足的地方，一个是需要使用root权限才能够运行我们的程序，另外一个我们在容器中使用ps看到pid为1的进程是/proc/self/exe child sh，而不是sh。所以这篇文章就讲讲如何解决这两个问题。
root权限 在Linux namespace中，只有user namespace 是可以被普通用户创建的，其他的namespace 都需要有root权限才可以。但这样就会有问题：
1、并不是每个用户都有sudo权限；
2、进程的安全性。
其实第一点还好解决，关键是第二点，运行的进程是以root权限运行的，这就有可能导致安全问题，比如，容器内的进程受到攻击，控制权到了攻击者的手中，此时的进程是用root权限运行的，所以攻击者可以用该进程执行任意权限的操作。
也有人可能会想，我们不是已经把所有的namespace都clone出来了么，rootfs也改变了，即使被攻击了，影响的范围也就是container中。说的是没错，不过，如果我们把主机的目录当作卷挂载到了container中，那么攻击者所能影响的范围就扩大到了主机中。所以，我们就把这个影响减少到最少—当前用户的权限。看看代码：
uid := os.Getuid() gid := os.Getgid() cmd.SysProcAttr = &amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUSER | syscall.CLONE_NEWUTS | syscall.CLONE_NEWNS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWNET | syscall.CLONE_NEWPID, UidMappings: []syscall.SysProcIDMap{{0, uid, 1}}, GidMappings: []syscall.SysProcIDMap{{0, gid, 1}}, Credential: &amp;syscall.Credential{ Uid: 0, Gid: 0, }, }第一行和第二行得到当前登陆用户的uid/gid (user id/ group id)；
第六行，我们做了一个uid的映射，syscall.SysProcIDMap第一个参数是容器内的用户的id，0是root，第二个参数是需要映射的用户的权限，第三个参数是映射范围，一般用1就可以，表示一一对应；第七行也是一样，只不过是gid的映射；
第8行，设置容器内用户的uid和gid，都为0，说明是用户是root，用户所在的组是root组
重新编译运行：
jin@k53:~/go-test$ go build namespace.go jin@k53:~/go-test$ ./namespace run sh p pid: 4342 c p pid: 0 c pid: 1 / # / # 可以看到现在不用root权限就可以运行了。docker 也不需要root权限就能运行呢，向docker又前进了一小步，而且，容器内是root，容器外，sh其实是以普通用户执行的，安全性又得到了保证。其实这种安全性是很粗糙的，关于容器的安全性，是一个比较有意思的话题，后面也许会单独谈谈。">
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="https://caijin.dev/zh/linux/namespace_improve/" /><link rel="prev" href="https://caijin.dev/zh/golang/golang%E9%AB%98%E7%BA%A7/" /><link rel="next" href="https://caijin.dev/zh/linux/cgroup/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Namespace_Improve",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/caijin.dev\/zh\/linux\/namespace_improve\/"
    },"genre": "posts","keywords": "linux, docker","wordcount":  273 ,
    "url": "https:\/\/caijin.dev\/zh\/linux\/namespace_improve\/","datePublished": "2019-08-16T21:03:23+08:00","dateModified": "2019-08-16T21:03:23+08:00","license": "xxxx","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "caijin"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/zh/" title="*&lt;^_^&gt;*"><span class="header-title-text">*&lt;^_^&gt;*</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/zh/"
                
                
              >文档</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/zh/categories/"
                
                
              >分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/zh/tags/"
                
                
              >标签</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="https://github.com/CaiJinKen"
                
                rel="noopener noreferrer" target="_blank"
              ><i class="fa fa-heart" style="color:red"></i> github</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li><li class="menu-item language-switch">
            <span role="button" aria-label="" title=""><i class="fa-solid fa-language fa-fw" aria-hidden="true"></i></span>
            <ul class="sub-menu"><li class="menu-item"></li></ul>
          </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/zh/" title="*&lt;^_^&gt;*"><span class="header-title-text">*&lt;^_^&gt;*</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/zh/"
                  
                  
                >文档</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/zh/categories/"
                  
                  
                >分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/zh/tags/"
                  
                  
                >标签</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="https://github.com/CaiJinKen"
                  
                  rel="noopener noreferrer" target="_blank"
                ><i class="fa fa-heart" style="color:red"></i> github</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title=""><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span><span class="menu-system-item language-switch">
              <span role="button" aria-label="" title="">简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden="true"></i></span>
              <select class="language-select" onchange="location = this.value;"><option disabled></option></select>
            </span></li>
      </ul>
    </nav>
  </div>
</header><main class="container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=""></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>Namespace_Improve</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><a href="https://caijin.dev"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="https://avatars.githubusercontent.com/u/36183188?s=400&amp;u=69ec665b3e4ffcc40a98072d56fbaa5b044c5968&amp;v=4" alt="caijin" data-title="caijin" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;caijin</a></span><span class="post-included-in">&nbsp;</span></div><div class="post-meta-line"><span title=""><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden="true"></i><time datetime="2019-08-16">2019-08-16</time></span>&nbsp;<span title=""><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i></span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i></span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span></span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><p>在上一篇<a href="https://caijinken.github.io/linux/namespace/"target="_blank" rel="external nofollow noopener noreferrer">namespace</a>的文章中，我们了解并通过程序写了一个简单版的容器，体验了Linux namespace的功能，但是还有两个美中不足的地方，一个是需要使用root权限才能够运行我们的程序，另外一个我们在容器中使用ps看到pid为1的进程是<code>/proc/self/exe child sh</code>，而不是sh。所以这篇文章就讲讲如何解决这两个问题。</p>
<h4 id="root权限" class="heading-element"><span>root权限</span>
  <a href="#root%e6%9d%83%e9%99%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>在Linux namespace中，只有user namespace 是可以被普通用户创建的，其他的namespace 都需要有root权限才可以。但这样就会有问题：</p>
<p>1、并不是每个用户都有sudo权限；</p>
<p>2、进程的安全性。</p>
<p>其实第一点还好解决，关键是第二点，运行的进程是以root权限运行的，这就有可能导致安全问题，比如，容器内的进程受到攻击，控制权到了攻击者的手中，此时的进程是用root权限运行的，所以攻击者可以用该进程执行任意权限的操作。</p>
<p>也有人可能会想，我们不是已经把所有的namespace都clone出来了么，rootfs也改变了，即使被攻击了，影响的范围也就是container中。说的是没错，不过，如果我们把主机的目录当作卷挂载到了container中，那么攻击者所能影响的范围就扩大到了主机中。所以，我们就把这个影响减少到最少&mdash;当前用户的权限。看看代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span> <span style="color:#a6e22e">uid</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getuid</span>()
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">gid</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getgid</span>()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">SysProcAttr</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">SysProcAttr</span>{
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Cloneflags</span>: <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">CLONE_NEWUSER</span> | <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">CLONE_NEWUTS</span> | <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">CLONE_NEWNS</span> | <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">CLONE_NEWIPC</span> | <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">CLONE_NEWNET</span> | <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">CLONE_NEWPID</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">UidMappings</span>: []<span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">SysProcIDMap</span>{{<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">uid</span>, <span style="color:#ae81ff">1</span>}},
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">GidMappings</span>: []<span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">SysProcIDMap</span>{{<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">gid</span>, <span style="color:#ae81ff">1</span>}},
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">Credential</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Credential</span>{
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">Uid</span>: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">Gid</span>: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>     },
</span></span><span style="display:flex;"><span> }</span></span></code></pre></div><p>第一行和第二行得到当前登陆用户的uid/gid (user id/ group id)；</p>
<p>第六行，我们做了一个uid的映射，syscall.SysProcIDMap第一个参数是容器内的用户的id，0是root，第二个参数是需要映射的用户的权限，第三个参数是映射范围，一般用1就可以，表示一一对应；第七行也是一样，只不过是gid的映射；</p>
<p>第8行，设置容器内用户的uid和gid，都为0，说明是用户是root，用户所在的组是root组</p>
<p>重新编译运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>jin@k53:~/go-test$ go build namespace.go 
</span></span><span style="display:flex;"><span>jin@k53:~/go-test$ ./namespace run sh
</span></span><span style="display:flex;"><span>p pid: <span style="color:#ae81ff">4342</span>
</span></span><span style="display:flex;"><span>c p pid: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>c pid: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># </span>
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># </span></span></span></code></pre></div><p>可以看到现在不用root权限就可以运行了。docker 也不需要root权限就能运行呢，向docker又前进了一小步，而且，容器内是root，容器外，sh其实是以普通用户执行的，安全性又得到了保证。其实这种安全性是很粗糙的，关于容器的安全性，是一个比较有意思的话题，后面也许会单独谈谈。</p>
<h4 id="pid-1" class="heading-element"><span>PID 1</span>
  <a href="#pid-1" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>我们使用ps命令可以看到，pid为1的进程并不是我们想要的sh，而是/proc/self/exec</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>/ <span style="color:#75715e"># ps</span>
</span></span><span style="display:flex;"><span>PID   USER     TIME  COMMAND
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span> root      0:00 /proc/self/exe child sh
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">4</span> root      0:00 sh
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">6</span> root      0:00 ps</span></span></code></pre></div><p>那么我们怎么把sh变成pid为1的进程呢？？？把/proc/self/exe干掉，它被kill掉以后，pid最小的就变成sh了，看起是这样的，不过可别忘了，linux中pid为1的进程一般都是init进程，比如systemd之类，如果init进程被kill了，那么其他的进程也会被干掉了，系统就gg了，所以这样是行不通的。我们可以试一下，可以看到并没什么用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>/ <span style="color:#75715e"># ps</span>
</span></span><span style="display:flex;"><span>PID   USER     TIME  COMMAND
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span> root      0:00 /proc/self/exe child sh
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">4</span> root      0:00 sh
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">5</span> root      0:00 ps
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># kill -9 1</span>
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># ps</span>
</span></span><span style="display:flex;"><span>PID   USER     TIME  COMMAND
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span> root      0:00 /proc/self/exe child sh
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">4</span> root      0:00 sh
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">6</span> root      0:00 ps
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># </span></span></span></code></pre></div><p>linux中有个函数execve，可以使用执行的进程替换父进程。可以使用man execve看一下使用方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>jin@k53:~$ man execve
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXECVE<span style="color:#f92672">(</span>2<span style="color:#f92672">)</span>         Linux Programmer<span style="color:#960050;background-color:#1e0010">&#39;</span>s Manual                  EXECVE<span style="color:#f92672">(</span>2<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NAME
</span></span><span style="display:flex;"><span>       execve - execute program
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SYNOPSIS
</span></span><span style="display:flex;"><span>       <span style="color:#75715e">#include &lt;unistd.h&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       int execve<span style="color:#f92672">(</span>const char *filename, char *const argv<span style="color:#f92672">[]</span>,
</span></span><span style="display:flex;"><span>                  char *const envp<span style="color:#f92672">[])</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DESCRIPTION
</span></span><span style="display:flex;"><span>       execve<span style="color:#f92672">()</span>  executes the program pointed to by filename.  This causes the program that is currently being run by the calling process to be replaced with a new program, with newly initialized stack,
</span></span><span style="display:flex;"><span>       heap, and <span style="color:#f92672">(</span>initialized and uninitialized<span style="color:#f92672">)</span> data segments.</span></span></code></pre></div><p>我们把child中的exec.Command 换成syscall.Exec()</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">child</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">must</span>(<span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Chroot</span>(<span style="color:#e6db74">&#34;/home/jin/rootfs/&#34;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">must</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Chdir</span>(<span style="color:#e6db74">&#34;/&#34;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Setenv</span>(<span style="color:#e6db74">&#34;HOME&#34;</span>, <span style="color:#e6db74">&#34;/&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">must</span>(<span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Mount</span>(<span style="color:#e6db74">&#34;proc&#34;</span>, <span style="color:#e6db74">&#34;proc&#34;</span>, <span style="color:#e6db74">&#34;proc&#34;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;&#34;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">must</span>(<span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Sethostname</span>([]byte(<span style="color:#e6db74">&#34;container&#34;</span>)))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">exec</span>.<span style="color:#a6e22e">LookPath</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">must</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">must</span>(<span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Exec</span>(<span style="color:#a6e22e">path</span>, append([]<span style="color:#66d9ef">string</span>{<span style="color:#a6e22e">path</span>}, <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>[<span style="color:#ae81ff">3</span>:]<span style="color:#f92672">...</span>), <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Environ</span>())) 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">must</span>(<span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Unmount</span>(<span style="color:#e6db74">&#34;proc&#34;</span>, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>syscall.Exec()和exec.Command()有个很大的不同是，exec()的可执行文件的路径必须是绝对路径，Command()</p>
<p>则没有这个要求，它会调用exec.LookPath()去自动获得path。</p>
<p>最后编译运行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>jin@k53:~/go-test$ ./namespace run sh
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># ps</span>
</span></span><span style="display:flex;"><span>PID   USER     TIME  COMMAND
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span> root      0:00 /bin/sh
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">4</span> root      0:00 ps
</span></span><span style="display:flex;"><span>/ <span style="color:#75715e"># </span></span></span></code></pre></div><p>可以看到，我们自己写的container已经和docker运行bash之后是一样的了。耶耶耶！✌️</p>
</div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="">&nbsp;</span>
      </div><div class="post-info-license">
            <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span>
          </div></div><div class="post-info-line">
        <div class="post-info-md"></div>
        <div class="post-info-share">
          <span><a href="javascript:void(0);" title=" X" data-sharer="twitter" data-url="https://caijin.dev/zh/linux/namespace_improve/" data-title="Namespace_Improve" data-hashtags="linux,docker"><i class="fa-brands fa-x-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title=" Facebook" data-sharer="facebook" data-url="https://caijin.dev/zh/linux/namespace_improve/" data-hashtag="linux"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title=" 微博" data-sharer="weibo" data-url="https://caijin.dev/zh/linux/namespace_improve/" data-title="Namespace_Improve"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href="/zh/tags/linux/" class="post-tag" title=" - Linux">Linux</a><a href="/zh/tags/docker/" class="post-tag" title=" - Docker">Docker</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();"></a></span>&nbsp;|&nbsp;<span><a href="/zh/"></a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/zh/golang/golang%E9%AB%98%E7%BA%A7/" class="post-nav-item" rel="prev" title="Golang高级001"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>Golang高级001</a>
      <a href="/zh/linux/cgroup/" class="post-nav-item" rel="next" title="Cgroup">Cgroup<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article>

  <aside class="toc" id="toc-auto" aria-label=""><h2 class="toc-title">&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered order-2">
        </div><div class="footer-line copyright order-1" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2024</span><span class="author" itemprop="copyrightHolder">
              <a href="https://caijin.dev"target="_blank" rel="external nofollow noopener noreferrer">caijin</a></span><span class="license footer-divider">MIT</span></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label=""><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><noscript>
    <div class="noscript-warning"></div>
  </noscript>
</div><link rel="preload" href="/lib/katex/katex.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/katex/katex.min.css"></noscript><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script src="/js/flyfish.js" defer></script><script>window.config={"code":{"copyTitle":"","editLockTitle":"","editUnLockTitle":"","editable":true,"maxShownLines":10},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"","link":"","message":""},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"version":"v0.3.9"};</script><script src="/js/theme.min.js" defer></script></body>
</html>
